THERE_BE_DRAGONS_HERE
Deprecation: The method SequenceableCollection sortBy: has been deprecated.
use #sort: or #sorted: instead
29 June 2011 4:02:39 pm

VM: Mac OS - intel - 1067 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51] Seaside 3.0
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /Users/diegolont/Documents/Delware/Promotie/summerschool/Seaside.app/Contents/Resources
Trusted Dir /foobar/tooBar/forSqueak/bogus
Untrusted Dir /Users/diegolont/Library/Preferences/Squeak/Internet/My Squeak

OrderedCollection(Object)>>deprecated:on:in:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anExplanationString: 	'use #sort: or #sorted: instead'
		date: 	'04 September 2010'
		version: 	'Pharo1.2'
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	2


OrderedCollection(SequenceableCollection)>>sortBy:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[:a :b | a voteValue > b voteValue]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	2


FOHome>>renderQuestionsOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


[self renderQuestionsOn: canvas] in FOHome>>renderContentOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


BlockClosure>>renderOn:
	Receiver: [self renderQuestionsOn: canvas]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOHome>>renderContentOn:
		startpc: 	44
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'homepage')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'homepage')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'homepage')


FOHome>>renderContentOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOHome
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOHome
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOHome
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOHome(WAComponent)>>accept:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOHome
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOHome(WAComponent)>>accept:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOHome(WAComponent)>>acceptDecorated:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOHome(WAPainter)>>renderWithContext:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


FOHome(WAPainter)>>renderOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOHome
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOHome
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
OrderedCollection(Object)>>deprecated:on:in:
OrderedCollection(SequenceableCollection)>>sortBy:
FOHome>>renderQuestionsOn:
[self renderQuestionsOn: canvas] in FOHome>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOHome>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOHome(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOHome(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOHome(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOHome(WAPainter)>>renderWithContext:
FOHome(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>captureAndInvoke
WARenderLoopMain>>start
FOSession(WASession)>>start
[^ self start] in FOSession(WASession)>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
FOSession(WASession)>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAgileOverflow>>logout
4 July 2011 11:23:24 am

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAgileOverflow(Object)>>doesNotUnderstand: #logout
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		aMessage: 	logout
		exception: 	MessageNotUnderstood: FOAgileOverflow>>logout
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	''


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#('Logout')
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
		key: 	'mlpPvxk9t0ib_iaC'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	782932
		previousTiming: 	25


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	782932
		previousTiming: 	25


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	782932
		previousTiming: 	25


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
FOAgileOverflow(Object)>>doesNotUnderstand: #logout
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAgileOverflow>>logout
4 July 2011 11:25:02 am

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAgileOverflow(Object)>>doesNotUnderstand: #logout
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		aMessage: 	logout
		exception: 	MessageNotUnderstood: FOAgileOverflow>>logout
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	''


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#('Logout')
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
		key: 	'mlpPvxk9t0ib_iaC'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	880441
		previousTiming: 	60277


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	880441
		previousTiming: 	60277


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	880441
		previousTiming: 	60277


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=hq6i-BQ0uKlmXCd9&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
FOAgileOverflow(Object)>>doesNotUnderstand: #logout
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 11:56:50 am

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233407
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233407
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233407
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233407
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233407
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233407
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		event: 	[923@226 mouseUp 47708927 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [923@226 mouseUp 47708927 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		timeStamp: 	47708927
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	923@226
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		aMorph: 	a PluggableListMorph(563871744)
		localEvt: 	[923@226 mouseUp 47708927 nil]
		index: 	2
		child: 	a TransformMorph(152043520)
		morphs: 	an Array(a TransformMorph(152043520))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		aMorph: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	923@226 corner: 939@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	923@226 corner: 939@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1055653888)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[923@226 923@226 mouseMove 47708818 nil]
		targetOffset: 	118@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 47708818 923 226 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(3407872) a Plugg...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[923@226 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(3407872) a Plugg...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	923@226 corner: 939@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	923@226 corner: 939@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1055653888)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[923@226 923@226 mouseMove 47708818 nil]
		targetOffset: 	118@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 47708818 923 226 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	923@226 corner: 939@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	923@226 corner: 939@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1055653888)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[923@226 923@226 mouseMove 47708818 nil]
		targetOffset: 	118@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 47708818 923 226 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
	Receiver's instance variables: 
		bounds: 	923@226 corner: 939@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	923@226 corner: 939@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1055653888)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[923@226 923@226 mouseMove 47708818 nil]
		targetOffset: 	118@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 47708818 923 226 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[923@226 mouseUp 47708927 nil]
		evt: 	[923@226 mouseUp 47708927 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	923@226 corner: 939@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	923@226 corner: 939@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1055653888)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[923@226 923@226 mouseMove 47708818 nil]
		targetOffset: 	118@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 47708818 923 226 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[923@226 mouseUp 47708927 nil]
		evtBuf: 	#(1 47708927 923 226 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	923@226 corner: 939@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	923@226 corner: 939@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1055653888)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[923@226 923@226 mouseMove 47708818 nil]
		targetOffset: 	118@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 47708818 923 226 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(53...etc...
		lastStepTime: 	2788093
		lastStepMessage: 	nil
		lastCycleTime: 	2788133
		alarms: 	a Heap()
		lastAlarmTime: 	2788093
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:26:37 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235196
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235196
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235196
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235196
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235196
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235196
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		event: 	[921@230 mouseUp 49496449 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [921@230 mouseUp 49496449 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		timeStamp: 	49496449
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	921@230
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		aMorph: 	a PluggableListMorph(563871744)
		localEvt: 	[921@230 mouseUp 49496449 nil]
		index: 	2
		child: 	a TransformMorph(152043520)
		morphs: 	an Array(a TransformMorph(152043520))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		aMorph: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	921@230 corner: 937@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@230 corner: 937@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(756023296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@230 mouseUp 49496449 nil]
		targetOffset: 	116@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49496449 921 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(763887616) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[921@230 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(763887616) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	921@230 corner: 937@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@230 corner: 937@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(756023296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@230 mouseUp 49496449 nil]
		targetOffset: 	116@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49496449 921 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	921@230 corner: 937@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@230 corner: 937@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(756023296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@230 mouseUp 49496449 nil]
		targetOffset: 	116@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49496449 921 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
	Receiver's instance variables: 
		bounds: 	921@230 corner: 937@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@230 corner: 937@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(756023296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@230 mouseUp 49496449 nil]
		targetOffset: 	116@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49496449 921 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@230 mouseUp 49496449 nil]
		evt: 	[921@230 mouseUp 49496449 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	921@230 corner: 937@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@230 corner: 937@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(756023296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@230 mouseUp 49496449 nil]
		targetOffset: 	116@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49496449 921 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[921@230 mouseUp 49496449 nil]
		evtBuf: 	#(1 49496449 921 230 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	921@230 corner: 937@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@230 corner: 937@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(756023296)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@230 mouseUp 49496449 nil]
		targetOffset: 	116@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49496449 921 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(53...etc...
		lastStepTime: 	4575608
		lastStepMessage: 	nil
		lastCycleTime: 	4575648
		alarms: 	a Heap()
		lastAlarmTime: 	4575608
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:27:22 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	an Array(TestPost>>#testPostVoteValue)
		errorSelected: 	nil
		lastUpdate: 	3487235240
		result: 	7 run, 5 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	an Array(TestPost>>#testPostVoteValue)
		errorSelected: 	nil
		lastUpdate: 	3487235240
		result: 	7 run, 5 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	an Array(TestPost>>#testPostVoteValue)
		errorSelected: 	nil
		lastUpdate: 	3487235240
		result: 	7 run, 5 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	an Array(TestPost>>#testPostVoteValue)
		errorSelected: 	nil
		lastUpdate: 	3487235240
		result: 	7 run, 5 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	an Array(TestPost>>#testPostVoteValue)
		errorSelected: 	nil
		lastUpdate: 	3487235240
		result: 	7 run, 5 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	an Array(TestPost>>#testPostVoteValue)
		errorSelected: 	nil
		lastUpdate: 	3487235240
		result: 	7 run, 5 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		event: 	[914@236 mouseUp 49541112 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [914@236 mouseUp 49541112 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		timeStamp: 	49541112
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	914@236
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		aMorph: 	a PluggableListMorph(563871744)
		localEvt: 	[914@236 mouseUp 49541112 nil]
		index: 	2
		child: 	a TransformMorph(152043520)
		morphs: 	an Array(a TransformMorph(152043520))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		aMorph: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	914@236 corner: 930@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	914@236 corner: 930@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(39583744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[914@237 914@236 mouseMove 49541112 nil]
		targetOffset: 	109@14
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49541112 914 236 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(61079552) a Plug...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[914@236 mouseOver nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(61079552) a Plug...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	914@236 corner: 930@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	914@236 corner: 930@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(39583744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[914@237 914@236 mouseMove 49541112 nil]
		targetOffset: 	109@14
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49541112 914 236 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	914@236 corner: 930@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	914@236 corner: 930@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(39583744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[914@237 914@236 mouseMove 49541112 nil]
		targetOffset: 	109@14
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49541112 914 236 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
	Receiver's instance variables: 
		bounds: 	914@236 corner: 930@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	914@236 corner: 930@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(39583744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[914@237 914@236 mouseMove 49541112 nil]
		targetOffset: 	109@14
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49541112 914 236 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[914@236 mouseUp 49541112 nil]
		evt: 	[914@236 mouseUp 49541112 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	914@236 corner: 930@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	914@236 corner: 930@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(39583744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[914@237 914@236 mouseMove 49541112 nil]
		targetOffset: 	109@14
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49541112 914 236 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[914@236 mouseUp 49541112 nil]
		evtBuf: 	#(1 49541112 914 236 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	914@236 corner: 930@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	914@236 corner: 930@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(39583744)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[914@237 914@236 mouseMove 49541112 nil]
		targetOffset: 	109@14
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49541112 914 236 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	4620263
		lastStepMessage: 	nil
		lastCycleTime: 	4620304
		alarms: 	a Heap()
		lastAlarmTime: 	4620263
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:27:37 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235255
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235255
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235255
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235255
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235255
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235255
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		event: 	[1032@229 mouseUp 49556322 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [1032@229 mouseUp 49556322 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		timeStamp: 	49556322
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	1032@229
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		aMorph: 	a PluggableListMorph(563871744)
		localEvt: 	[1032@229 mouseUp 49556322 nil]
		index: 	2
		child: 	a TransformMorph(152043520)
		morphs: 	an Array(a TransformMorph(152043520))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		aMorph: 	a PluggableListMorph(563871744)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(563871744)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
	Receiver's instance variables: 
		bounds: 	805@223 corner: 1116@416
		owner: 	a PluggableStandardWindow(519045120)
		submorphs: 	an Array(a TransformMorph(152043520))
		fullBounds: 	805@223 corner: 1116@416
		color: 	Color white
		extension: 	a MorphExtension (676331520) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(570687488)
		scroller: 	a TransformMorph(152043520)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(363069440)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(381419520)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	1032@229 corner: 1048@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	1032@229 corner: 1048@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(178257920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[1032@228 1032@229 mouseMove 49556322 nil]
		targetOffset: 	227@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49556322 1032 229 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(186122240) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[1032@229 mouseOver nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(186122240) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	1032@229 corner: 1048@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	1032@229 corner: 1048@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(178257920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[1032@228 1032@229 mouseMove 49556322 nil]
		targetOffset: 	227@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49556322 1032 229 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		focusHolder: 	a PluggableListMorph(563871744)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	1032@229 corner: 1048@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	1032@229 corner: 1048@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(178257920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[1032@228 1032@229 mouseMove 49556322 nil]
		targetOffset: 	227@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49556322 1032 229 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
	Receiver's instance variables: 
		bounds: 	1032@229 corner: 1048@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	1032@229 corner: 1048@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(178257920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[1032@228 1032@229 mouseMove 49556322 nil]
		targetOffset: 	227@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49556322 1032 229 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[1032@229 mouseUp 49556322 nil]
		evt: 	[1032@229 mouseUp 49556322 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	1032@229 corner: 1048@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	1032@229 corner: 1048@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(178257920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[1032@228 1032@229 mouseMove 49556322 nil]
		targetOffset: 	227@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49556322 1032 229 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[1032@229 mouseUp 49556322 nil]
		evtBuf: 	#(1 49556322 1032 229 0 0 2 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	1032@229 corner: 1048@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	1032@229 corner: 1048@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(178257920)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[1032@228 1032@229 mouseMove 49556322 nil]
		targetOffset: 	227@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49556322 1032 229 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(53...etc...
		lastStepTime: 	4635458
		lastStepMessage: 	nil
		lastCycleTime: 	4635498
		alarms: 	a Heap()
		lastAlarmTime: 	4635458
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:28:36 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235311
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235311
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235311
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235311
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235311
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235311
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[842@230 mouseUp 49614947 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [842@230 mouseUp 49614947 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	49614947
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	842@230
		handler: 	nil
		wasHandled: 	true
		whichButton: 	2


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[842@230 mouseUp 49614947 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(95944704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 mouseUp 49614947 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49614947 842 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(104071168) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[842@230 mouseOver yellow nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(104071168) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(95944704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 mouseUp 49614947 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49614947 842 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(95944704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 mouseUp 49614947 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49614947 842 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(95944704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 mouseUp 49614947 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49614947 842 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 49614947 nil]
		evt: 	[842@230 mouseUp 49614947 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(95944704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 mouseUp 49614947 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49614947 842 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[842@230 mouseUp 49614947 nil]
		evtBuf: 	#(1 49614947 842 230 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(95944704)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 mouseUp 49614947 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 49614947 842 230 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	4694083
		lastStepMessage: 	nil
		lastCycleTime: 	4694123
		alarms: 	a Heap()
		lastAlarmTime: 	4694083
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was 1.
4 July 2011 1:24:56 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was 1.'
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		expected: 	0
		actual: 	1
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost>>testPostVoteValue
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVoteValue)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVoteValue nil nil nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[915@225 mouseUp 52995708 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [915@225 mouseUp 52995708 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	52995708
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	915@225
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[915@225 mouseUp 52995708 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	915@225 corner: 931@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	915@225 corner: 931@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(431489024)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[915@225 mouseUp 52995708 nil]
		targetOffset: 	155@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52995708 915 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(439615488) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[915@225 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(439615488) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	915@225 corner: 931@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	915@225 corner: 931@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(431489024)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[915@225 mouseUp 52995708 nil]
		targetOffset: 	155@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52995708 915 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	915@225 corner: 931@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	915@225 corner: 931@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(431489024)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[915@225 mouseUp 52995708 nil]
		targetOffset: 	155@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52995708 915 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
	Receiver's instance variables: 
		bounds: 	915@225 corner: 931@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	915@225 corner: 931@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(431489024)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[915@225 mouseUp 52995708 nil]
		targetOffset: 	155@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52995708 915 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[915@225 mouseUp 52995708 nil]
		evt: 	[915@225 mouseUp 52995708 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	915@225 corner: 931@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	915@225 corner: 931@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(431489024)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[915@225 mouseUp 52995708 nil]
		targetOffset: 	155@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52995708 915 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[915@225 mouseUp 52995708 nil]
		evtBuf: 	#(1 52995708 915 225 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	915@225 corner: 931@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	915@225 corner: 931@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(431489024)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[915@225 mouseUp 52995708 nil]
		targetOffset: 	155@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52995708 915 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	8074865
		lastStepMessage: 	nil
		lastCycleTime: 	8074905
		alarms: 	a Heap()
		lastAlarmTime: 	8074865
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVoteValue
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was 1.
4 July 2011 1:24:58 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was 1.'
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		expected: 	0
		actual: 	1
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost>>testPostVoteValue
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVoteValue)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVoteValue nil nil nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[916@225 mouseUp 52997236 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [916@225 mouseUp 52997236 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	52997236
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	916@225
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[916@225 mouseUp 52997236 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	916@225 corner: 932@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	916@225 corner: 932@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(771489792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[916@225 mouseUp 52997236 nil]
		targetOffset: 	156@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52997236 916 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(793247744) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[916@225 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(793247744) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	916@225 corner: 932@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	916@225 corner: 932@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(771489792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[916@225 mouseUp 52997236 nil]
		targetOffset: 	156@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52997236 916 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	916@225 corner: 932@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	916@225 corner: 932@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(771489792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[916@225 mouseUp 52997236 nil]
		targetOffset: 	156@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52997236 916 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
	Receiver's instance variables: 
		bounds: 	916@225 corner: 932@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	916@225 corner: 932@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(771489792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[916@225 mouseUp 52997236 nil]
		targetOffset: 	156@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52997236 916 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[916@225 mouseUp 52997236 nil]
		evt: 	[916@225 mouseUp 52997236 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	916@225 corner: 932@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	916@225 corner: 932@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(771489792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[916@225 mouseUp 52997236 nil]
		targetOffset: 	156@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52997236 916 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[916@225 mouseUp 52997236 nil]
		evtBuf: 	#(1 52997236 916 225 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	916@225 corner: 932@241
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	916@225 corner: 932@241
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(771489792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[916@225 mouseUp 52997236 nil]
		targetOffset: 	156@2
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 52997236 916 225 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	8076377
		lastStepMessage: 	nil
		lastCycleTime: 	8076417
		alarms: 	a Heap()
		lastAlarmTime: 	8076377
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVoteValue
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was 1.
4 July 2011 1:25:01 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was 1.'
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		expected: 	0
		actual: 	1
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost>>testPostVoteValue
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVoteValue)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVoteValue nil nil nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVoteValue TestPost>>#testVotesHaveUniqu...etc...
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238693
		result: 	7 run, 5 passes, 0 expected failures, 2 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[821@236 mouseUp 53000684 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [821@236 mouseUp 53000684 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53000684
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	821@236
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[821@236 mouseUp 53000684 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testPostVoteValue' 'TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	821@236 corner: 837@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	821@236 corner: 837@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(857210880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[821@236 821@236 mouseMove 53000122 nil]
		targetOffset: 	61@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53000122 821 236 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(866648064) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[821@236 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(866648064) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	821@236 corner: 837@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	821@236 corner: 837@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(857210880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[821@236 821@236 mouseMove 53000122 nil]
		targetOffset: 	61@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53000122 821 236 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	821@236 corner: 837@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	821@236 corner: 837@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(857210880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[821@236 821@236 mouseMove 53000122 nil]
		targetOffset: 	61@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53000122 821 236 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
	Receiver's instance variables: 
		bounds: 	821@236 corner: 837@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	821@236 corner: 837@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(857210880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[821@236 821@236 mouseMove 53000122 nil]
		targetOffset: 	61@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53000122 821 236 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[821@236 mouseUp 53000684 nil]
		evt: 	[821@236 mouseUp 53000684 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	821@236 corner: 837@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	821@236 corner: 837@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(857210880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[821@236 821@236 mouseMove 53000122 nil]
		targetOffset: 	61@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53000122 821 236 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[821@236 mouseUp 53000684 nil]
		evtBuf: 	#(1 53000684 821 236 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	821@236 corner: 837@252
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	821@236 corner: 837@252
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(857210880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[821@236 821@236 mouseMove 53000122 nil]
		targetOffset: 	61@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53000122 821 236 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	8079816
		lastStepMessage: 	nil
		lastCycleTime: 	8079856
		alarms: 	a Heap()
		lastAlarmTime: 	8079816
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVoteValue
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:27:36 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238854
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238854
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238854
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238854
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238854
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238854
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[921@227 mouseUp 53155811 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [921@227 mouseUp 53155811 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53155811
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	921@227
		handler: 	nil
		wasHandled: 	true
		whichButton: 	2


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[921@227 mouseUp 53155811 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	921@227 corner: 937@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@227 corner: 937@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(255590400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@227 mouseUp 53155811 nil]
		targetOffset: 	161@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53155811 921 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(55050240) a Plug...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[921@227 mouseOver yellow nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(55050240) a Plug...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	921@227 corner: 937@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@227 corner: 937@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(255590400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@227 mouseUp 53155811 nil]
		targetOffset: 	161@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53155811 921 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	921@227 corner: 937@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@227 corner: 937@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(255590400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@227 mouseUp 53155811 nil]
		targetOffset: 	161@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53155811 921 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
	Receiver's instance variables: 
		bounds: 	921@227 corner: 937@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@227 corner: 937@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(255590400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@227 mouseUp 53155811 nil]
		targetOffset: 	161@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53155811 921 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[921@227 mouseUp 53155811 nil]
		evt: 	[921@227 mouseUp 53155811 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	921@227 corner: 937@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@227 corner: 937@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(255590400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@227 mouseUp 53155811 nil]
		targetOffset: 	161@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53155811 921 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[921@227 mouseUp 53155811 nil]
		evtBuf: 	#(1 53155811 921 227 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	921@227 corner: 937@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	921@227 corner: 937@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(255590400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[921@227 mouseUp 53155811 nil]
		targetOffset: 	161@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53155811 921 227 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	8234949
		lastStepMessage: 	nil
		lastCycleTime: 	8234989
		alarms: 	a Heap()
		lastAlarmTime: 	8234949
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:34:55 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[973@233 mouseUp 53593971 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [973@233 mouseUp 53593971 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53593971
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	973@233
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[973@233 mouseUp 53593971 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	973@233 corner: 989@249
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	973@233 corner: 989@249
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(449839104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[973@233 973@233 mouseMove 53593800 nil]
		targetOffset: 	213@10
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53593800 973 233 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(457965568) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[973@233 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(457965568) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	973@233 corner: 989@249
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	973@233 corner: 989@249
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(449839104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[973@233 973@233 mouseMove 53593800 nil]
		targetOffset: 	213@10
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53593800 973 233 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	973@233 corner: 989@249
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	973@233 corner: 989@249
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(449839104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[973@233 973@233 mouseMove 53593800 nil]
		targetOffset: 	213@10
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53593800 973 233 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
	Receiver's instance variables: 
		bounds: 	973@233 corner: 989@249
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	973@233 corner: 989@249
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(449839104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[973@233 973@233 mouseMove 53593800 nil]
		targetOffset: 	213@10
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53593800 973 233 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[973@233 mouseUp 53593971 nil]
		evt: 	[973@233 mouseUp 53593971 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	973@233 corner: 989@249
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	973@233 corner: 989@249
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(449839104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[973@233 973@233 mouseMove 53593800 nil]
		targetOffset: 	213@10
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53593800 973 233 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[973@233 mouseUp 53593971 nil]
		evtBuf: 	#(1 53593971 973 233 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	973@233 corner: 989@249
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	973@233 corner: 989@249
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(449839104)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[973@233 973@233 mouseMove 53593800 nil]
		targetOffset: 	213@10
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53593800 973 233 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	8673128
		lastStepMessage: 	nil
		lastCycleTime: 	8673168
		alarms: 	a Heap()
		lastAlarmTime: 	8673128
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:35:27 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[797@235 mouseUp 53625952 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [797@235 mouseUp 53625952 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53625952
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	797@235
		handler: 	nil
		wasHandled: 	true
		whichButton: 	2


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[797@235 mouseUp 53625952 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	797@235 corner: 813@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	797@235 corner: 813@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(250085376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[797@235 797@235 mouseMove 53625468 nil]
		targetOffset: 	37@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53625468 797 235 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(664797184) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[797@235 mouseOver yellow nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(664797184) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	797@235 corner: 813@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	797@235 corner: 813@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(250085376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[797@235 797@235 mouseMove 53625468 nil]
		targetOffset: 	37@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53625468 797 235 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	797@235 corner: 813@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	797@235 corner: 813@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(250085376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[797@235 797@235 mouseMove 53625468 nil]
		targetOffset: 	37@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53625468 797 235 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
	Receiver's instance variables: 
		bounds: 	797@235 corner: 813@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	797@235 corner: 813@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(250085376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[797@235 797@235 mouseMove 53625468 nil]
		targetOffset: 	37@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53625468 797 235 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[797@235 mouseUp 53625952 nil]
		evt: 	[797@235 mouseUp 53625952 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	797@235 corner: 813@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	797@235 corner: 813@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(250085376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[797@235 797@235 mouseMove 53625468 nil]
		targetOffset: 	37@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53625468 797 235 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[797@235 mouseUp 53625952 nil]
		evtBuf: 	#(1 53625952 797 235 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	797@235 corner: 813@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	797@235 corner: 813@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(250085376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[797@235 797@235 mouseMove 53625468 nil]
		targetOffset: 	37@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53625468 797 235 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	8705098
		lastStepMessage: 	nil
		lastCycleTime: 	8705138
		alarms: 	a Heap()
		lastAlarmTime: 	8705098
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:35:31 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239293
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[890@234 mouseUp 53630148 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [890@234 mouseUp 53630148 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53630148
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	890@234
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[890@234 mouseUp 53630148 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(878706688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[890@234 mouseUp 53630148 nil]
		targetOffset: 	130@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53630148 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(900464640) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[890@234 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(900464640) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(878706688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[890@234 mouseUp 53630148 nil]
		targetOffset: 	130@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53630148 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(878706688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[890@234 mouseUp 53630148 nil]
		targetOffset: 	130@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53630148 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(878706688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[890@234 mouseUp 53630148 nil]
		targetOffset: 	130@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53630148 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53630148 nil]
		evt: 	[890@234 mouseUp 53630148 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(878706688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[890@234 mouseUp 53630148 nil]
		targetOffset: 	130@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53630148 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[890@234 mouseUp 53630148 nil]
		evtBuf: 	#(1 53630148 890 234 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(878706688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[890@234 mouseUp 53630148 nil]
		targetOffset: 	130@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53630148 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	8709291
		lastStepMessage: 	nil
		lastCycleTime: 	8709331
		alarms: 	a Heap()
		lastAlarmTime: 	8709291
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:36:13 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239372
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239372
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239372
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239372
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239372
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239372
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[890@234 mouseUp 53672721 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [890@234 mouseUp 53672721 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53672721
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	890@234
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[890@234 mouseUp 53672721 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(677642240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[889@235 890@234 mouseMove 53672721 nil]
		targetOffset: 	129@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53672721 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(699400192) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[890@234 mouseOver nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(699400192) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(677642240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[889@235 890@234 mouseMove 53672721 nil]
		targetOffset: 	129@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53672721 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(677642240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[889@235 890@234 mouseMove 53672721 nil]
		targetOffset: 	129@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53672721 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(677642240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[889@235 890@234 mouseMove 53672721 nil]
		targetOffset: 	129@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53672721 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[890@234 mouseUp 53672721 nil]
		evt: 	[890@234 mouseUp 53672721 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(677642240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[889@235 890@234 mouseMove 53672721 nil]
		targetOffset: 	129@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53672721 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[890@234 mouseUp 53672721 nil]
		evtBuf: 	#(1 53672721 890 234 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	890@234 corner: 906@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	890@234 corner: 906@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(677642240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[889@235 890@234 mouseMove 53672721 nil]
		targetOffset: 	129@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53672721 890 234 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	8751873
		lastStepMessage: 	nil
		lastCycleTime: 	8751913
		alarms: 	a Heap()
		lastAlarmTime: 	8751873
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 2 but was 3.
4 July 2011 1:40:01 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 2 but was 3.'
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	2
		actual: 	3
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost>>testVotesHaveUniqueAuthor
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239600
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testVotesHaveUniqueAuthor nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239600
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239600
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239600
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239600
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239600
		result: 	7 run, 6 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[866@232 mouseUp 53900857 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [866@232 mouseUp 53900857 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	53900857
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	866@232
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[866@232 mouseUp 53900857 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	866@232 corner: 882@248
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	866@232 corner: 882@248
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(918028288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[866@232 mouseUp 53900857 nil]
		targetOffset: 	106@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53900857 866 232 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(806092800) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[866@232 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(806092800) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	866@232 corner: 882@248
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	866@232 corner: 882@248
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(918028288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[866@232 mouseUp 53900857 nil]
		targetOffset: 	106@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53900857 866 232 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	866@232 corner: 882@248
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	866@232 corner: 882@248
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(918028288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[866@232 mouseUp 53900857 nil]
		targetOffset: 	106@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53900857 866 232 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
	Receiver's instance variables: 
		bounds: 	866@232 corner: 882@248
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	866@232 corner: 882@248
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(918028288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[866@232 mouseUp 53900857 nil]
		targetOffset: 	106@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53900857 866 232 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[866@232 mouseUp 53900857 nil]
		evt: 	[866@232 mouseUp 53900857 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	866@232 corner: 882@248
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	866@232 corner: 882@248
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(918028288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[866@232 mouseUp 53900857 nil]
		targetOffset: 	106@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53900857 866 232 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[866@232 mouseUp 53900857 nil]
		evtBuf: 	#(1 53900857 866 232 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	866@232 corner: 882@248
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	866@232 corner: 882@248
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(918028288)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[866@232 mouseUp 53900857 nil]
		targetOffset: 	106@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 53900857 866 232 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	8980011
		lastStepMessage: 	nil
		lastCycleTime: 	8980051
		alarms: 	a Heap()
		lastAlarmTime: 	8980011
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was 1.
4 July 2011 1:42:38 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was 1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239756
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239756
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239756
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239756
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239756
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239756
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[842@230 mouseUp 54057653 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [842@230 mouseUp 54057653 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	54057653
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	842@230
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[842@230 mouseUp 54057653 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(467140608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 842@230 mouseMove 54057372 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54057372 842 230 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(475004928) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[842@230 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(475004928) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(467140608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 842@230 mouseMove 54057372 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54057372 842 230 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(467140608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 842@230 mouseMove 54057372 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54057372 842 230 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(467140608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 842@230 mouseMove 54057372 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54057372 842 230 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@230 mouseUp 54057653 nil]
		evt: 	[842@230 mouseUp 54057653 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(467140608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 842@230 mouseMove 54057372 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54057372 842 230 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[842@230 mouseUp 54057653 nil]
		evtBuf: 	#(1 54057653 842 230 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	842@230 corner: 858@246
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@230 corner: 858@246
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(467140608)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@230 842@230 mouseMove 54057372 nil]
		targetOffset: 	82@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54057372 842 230 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OBSystemWindow(713293824))(an OBSys...etc...
		lastStepTime: 	9136789
		lastStepMessage: 	nil
		lastCycleTime: 	9136829
		alarms: 	a Heap()
		lastAlarmTime: 	9136789
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was 1.
4 July 2011 1:42:58 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was 1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[919@226 mouseUp 54076888 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [919@226 mouseUp 54076888 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	54076888
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	919@226
		handler: 	nil
		wasHandled: 	true
		whichButton: 	2


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[919@226 mouseUp 54076888 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	919@226 corner: 935@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	919@226 corner: 935@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834928640)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[919@226 mouseUp 54076888 nil]
		targetOffset: 	159@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54076888 919 226 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(843055104) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[919@226 mouseOver yellow nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(843055104) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	919@226 corner: 935@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	919@226 corner: 935@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834928640)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[919@226 mouseUp 54076888 nil]
		targetOffset: 	159@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54076888 919 226 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	919@226 corner: 935@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	919@226 corner: 935@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834928640)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[919@226 mouseUp 54076888 nil]
		targetOffset: 	159@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54076888 919 226 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
	Receiver's instance variables: 
		bounds: 	919@226 corner: 935@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	919@226 corner: 935@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834928640)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[919@226 mouseUp 54076888 nil]
		targetOffset: 	159@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54076888 919 226 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[919@226 mouseUp 54076888 nil]
		evt: 	[919@226 mouseUp 54076888 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	919@226 corner: 935@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	919@226 corner: 935@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834928640)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[919@226 mouseUp 54076888 nil]
		targetOffset: 	159@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54076888 919 226 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[919@226 mouseUp 54076888 nil]
		evtBuf: 	#(1 54076888 919 226 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	919@226 corner: 935@242
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	919@226 corner: 935@242
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834928640)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[919@226 mouseUp 54076888 nil]
		targetOffset: 	159@3
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54076888 919 226 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(85...etc...
		lastStepTime: 	9156026
		lastStepMessage: 	nil
		lastCycleTime: 	9156066
		alarms: 	a Heap()
		lastAlarmTime: 	9156026
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was 1.
4 July 2011 1:42:59 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was 1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487239774
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[877@227 mouseUp 54078276 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [877@227 mouseUp 54078276 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	54078276
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	877@227
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[877@227 mouseUp 54078276 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	877@227 corner: 893@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	877@227 corner: 893@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(300154880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[877@227 877@227 mouseMove 54078105 nil]
		targetOffset: 	117@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54078105 877 227 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(308281344) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[877@227 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(308281344) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	877@227 corner: 893@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	877@227 corner: 893@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(300154880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[877@227 877@227 mouseMove 54078105 nil]
		targetOffset: 	117@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54078105 877 227 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	877@227 corner: 893@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	877@227 corner: 893@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(300154880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[877@227 877@227 mouseMove 54078105 nil]
		targetOffset: 	117@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54078105 877 227 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
	Receiver's instance variables: 
		bounds: 	877@227 corner: 893@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	877@227 corner: 893@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(300154880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[877@227 877@227 mouseMove 54078105 nil]
		targetOffset: 	117@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54078105 877 227 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[877@227 mouseUp 54078276 nil]
		evt: 	[877@227 mouseUp 54078276 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	877@227 corner: 893@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	877@227 corner: 893@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(300154880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[877@227 877@227 mouseMove 54078105 nil]
		targetOffset: 	117@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54078105 877 227 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[877@227 mouseUp 54078276 nil]
		evtBuf: 	#(1 54078276 877 227 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	877@227 corner: 893@243
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	877@227 corner: 893@243
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(300154880)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[877@227 877@227 mouseMove 54078105 nil]
		targetOffset: 	117@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54078105 877 227 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(877658112))(an Ove...etc...
		lastStepTime: 	9157422
		lastStepMessage: 	nil
		lastCycleTime: 	9157462
		alarms: 	a Heap()
		lastAlarmTime: 	9157422
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was -1.
4 July 2011 1:53:59 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was -1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	-1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240437
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240437
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240437
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240437
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240437
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240437
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[870@229 mouseUp 54738036 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [870@229 mouseUp 54738036 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	54738036
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	870@229
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[870@229 mouseUp 54738036 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	870@229 corner: 886@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@229 corner: 886@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(741605376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@229 870@229 mouseMove 54737864 nil]
		targetOffset: 	110@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54737864 870 229 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(749731840) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[870@229 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(749731840) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	870@229 corner: 886@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@229 corner: 886@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(741605376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@229 870@229 mouseMove 54737864 nil]
		targetOffset: 	110@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54737864 870 229 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	870@229 corner: 886@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@229 corner: 886@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(741605376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@229 870@229 mouseMove 54737864 nil]
		targetOffset: 	110@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54737864 870 229 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
	Receiver's instance variables: 
		bounds: 	870@229 corner: 886@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@229 corner: 886@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(741605376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@229 870@229 mouseMove 54737864 nil]
		targetOffset: 	110@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54737864 870 229 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@229 mouseUp 54738036 nil]
		evt: 	[870@229 mouseUp 54738036 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	870@229 corner: 886@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@229 corner: 886@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(741605376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@229 870@229 mouseMove 54737864 nil]
		targetOffset: 	110@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54737864 870 229 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[870@229 mouseUp 54738036 nil]
		evtBuf: 	#(1 54738036 870 229 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	870@229 corner: 886@245
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@229 corner: 886@245
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(741605376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@229 870@229 mouseMove 54737864 nil]
		targetOffset: 	110@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54737864 870 229 0 0 0 1)
		lastKeyScanCode: 	31
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	9817179
		lastStepMessage: 	nil
		lastCycleTime: 	9817219
		alarms: 	a Heap()
		lastAlarmTime: 	9817179
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was -1.
4 July 2011 1:56:09 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was -1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	-1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240540
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240540
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240540
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240540
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240540
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240540
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[837@234 mouseUp 54868390 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [837@234 mouseUp 54868390 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	54868390
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	837@234
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[837@234 mouseUp 54868390 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	837@234 corner: 853@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	837@234 corner: 853@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(700186624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[837@234 837@234 mouseMove 54868047 nil]
		targetOffset: 	77@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54868047 837 234 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(708050944) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[837@234 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(708050944) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	837@234 corner: 853@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	837@234 corner: 853@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(700186624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[837@234 837@234 mouseMove 54868047 nil]
		targetOffset: 	77@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54868047 837 234 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	837@234 corner: 853@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	837@234 corner: 853@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(700186624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[837@234 837@234 mouseMove 54868047 nil]
		targetOffset: 	77@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54868047 837 234 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
	Receiver's instance variables: 
		bounds: 	837@234 corner: 853@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	837@234 corner: 853@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(700186624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[837@234 837@234 mouseMove 54868047 nil]
		targetOffset: 	77@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54868047 837 234 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[837@234 mouseUp 54868390 nil]
		evt: 	[837@234 mouseUp 54868390 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	837@234 corner: 853@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	837@234 corner: 853@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(700186624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[837@234 837@234 mouseMove 54868047 nil]
		targetOffset: 	77@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54868047 837 234 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[837@234 mouseUp 54868390 nil]
		evtBuf: 	#(1 54868390 837 234 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	837@234 corner: 853@250
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	837@234 corner: 853@250
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(700186624)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[837@234 837@234 mouseMove 54868047 nil]
		targetOffset: 	77@11
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 54868047 837 234 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(542375936))(an Ove...etc...
		lastStepTime: 	9947537
		lastStepMessage: 	nil
		lastCycleTime: 	9947577
		alarms: 	a Heap()
		lastAlarmTime: 	9947537
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: OrderedCollection>>votes
4 July 2011 1:58:52 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

OrderedCollection(Object)>>doesNotUnderstand: #votes
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aMessage: 	votes
		exception: 	MessageNotUnderstood: OrderedCollection>>votes
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	2


FOPost>>voteUp:
	Receiver: a FOPost
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection()
		content: 	nil


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue ...etc...
		errorSelected: 	TestPost>>#testLastVoteCounts
		lastUpdate: 	3487240729
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue ...etc...
		errorSelected: 	TestPost>>#testLastVoteCounts
		lastUpdate: 	3487240729
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue ...etc...
		errorSelected: 	TestPost>>#testLastVoteCounts
		lastUpdate: 	3487240729
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue ...etc...
		errorSelected: 	TestPost>>#testLastVoteCounts
		lastUpdate: 	3487240729
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue ...etc...
		errorSelected: 	TestPost>>#testLastVoteCounts
		lastUpdate: 	3487240729
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue ...etc...
		errorSelected: 	TestPost>>#testLastVoteCounts
		lastUpdate: 	3487240729
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		event: 	[900@427 mouseUp 55031365 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [900@427 mouseUp 55031365 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(873988096)
	Receiver's instance variables: 
		timeStamp: 	55031365
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	900@427
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		aMorph: 	a PluggableListMorph(873988096)
		localEvt: 	[900@427 mouseUp 55031365 nil]
		index: 	2
		child: 	a TransformMorph(459538432)
		morphs: 	an Array(a TransformMorph(459538432))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		aMorph: 	a PluggableListMorph(873988096)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(873988096)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
	Receiver's instance variables: 
		bounds: 	760@420 corner: 1071@592
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(459538432))
		fullBounds: 	760@420 corner: 1071@592
		color: 	Color white
		extension: 	a MorphExtension (983302144) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(880803840)
		scroller: 	a TransformMorph(459538432)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(670302208)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(688914432)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		focusHolder: 	a PluggableListMorph(873988096)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	900@427 corner: 916@443
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	900@427 corner: 916@443
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(586678272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[900@427 900@427 mouseMove 55030850 nil]
		targetOffset: 	140@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55030850 900 427 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(607649792) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[900@427 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(607649792) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		focusHolder: 	a PluggableListMorph(873988096)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	900@427 corner: 916@443
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	900@427 corner: 916@443
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(586678272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[900@427 900@427 mouseMove 55030850 nil]
		targetOffset: 	140@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55030850 900 427 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		focusHolder: 	a PluggableListMorph(873988096)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	900@427 corner: 916@443
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	900@427 corner: 916@443
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(586678272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[900@427 900@427 mouseMove 55030850 nil]
		targetOffset: 	140@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55030850 900 427 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
	Receiver's instance variables: 
		bounds: 	900@427 corner: 916@443
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	900@427 corner: 916@443
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(586678272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[900@427 900@427 mouseMove 55030850 nil]
		targetOffset: 	140@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55030850 900 427 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[900@427 mouseUp 55031365 nil]
		evt: 	[900@427 mouseUp 55031365 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	900@427 corner: 916@443
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	900@427 corner: 916@443
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(586678272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[900@427 900@427 mouseMove 55030850 nil]
		targetOffset: 	140@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55030850 900 427 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[900@427 mouseUp 55031365 nil]
		evtBuf: 	#(1 55031365 900 427 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	900@427 corner: 916@443
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	900@427 corner: 916@443
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(586678272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[900@427 900@427 mouseMove 55030850 nil]
		targetOffset: 	140@7
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55030850 900 427 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	10110513
		lastStepMessage: 	nil
		lastCycleTime: 	10110553
		alarms: 	a Heap()
		lastAlarmTime: 	10110513
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #votes
FOPost>>voteUp:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was -1.
4 July 2011 1:59:38 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was -1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	-1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240776
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240776
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240776
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240776
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240776
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487240776
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[842@246 mouseUp 55077541 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [842@246 mouseUp 55077541 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	55077541
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	842@246
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[842@246 mouseUp 55077541 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	842@246 corner: 858@262
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@246 corner: 858@262
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(513802240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@247 842@246 mouseMove 55077541 nil]
		targetOffset: 	82@24
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55077541 842 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(407371776) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[842@246 mouseOver nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(407371776) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	842@246 corner: 858@262
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@246 corner: 858@262
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(513802240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@247 842@246 mouseMove 55077541 nil]
		targetOffset: 	82@24
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55077541 842 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	842@246 corner: 858@262
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@246 corner: 858@262
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(513802240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@247 842@246 mouseMove 55077541 nil]
		targetOffset: 	82@24
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55077541 842 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
	Receiver's instance variables: 
		bounds: 	842@246 corner: 858@262
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@246 corner: 858@262
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(513802240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@247 842@246 mouseMove 55077541 nil]
		targetOffset: 	82@24
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55077541 842 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[842@246 mouseUp 55077541 nil]
		evt: 	[842@246 mouseUp 55077541 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	842@246 corner: 858@262
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@246 corner: 858@262
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(513802240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@247 842@246 mouseMove 55077541 nil]
		targetOffset: 	82@24
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55077541 842 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[842@246 mouseUp 55077541 nil]
		evtBuf: 	#(1 55077541 842 246 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	842@246 corner: 858@262
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	842@246 corner: 858@262
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(513802240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[842@247 842@246 mouseMove 55077541 nil]
		targetOffset: 	82@24
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55077541 842 246 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	10156688
		lastStepMessage: 	nil
		lastCycleTime: 	10156728
		alarms: 	a Heap()
		lastAlarmTime: 	10156688
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 0.
4 July 2011 2:03:26 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 0.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	1
		actual: 	0
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue...etc...
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241004
		result: 	8 run, 5 passes, 0 expected failures, 3 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue...etc...
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241004
		result: 	8 run, 5 passes, 0 expected failures, 3 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue...etc...
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241004
		result: 	8 run, 5 passes, 0 expected failures, 3 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue...etc...
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241004
		result: 	8 run, 5 passes, 0 expected failures, 3 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue...etc...
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241004
		result: 	8 run, 5 passes, 0 expected failures, 3 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts TestPost>>#testPostVoteValue...etc...
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241004
		result: 	8 run, 5 passes, 0 expected failures, 3 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[899@235 mouseUp 55305583 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [899@235 mouseUp 55305583 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	55305583
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	899@235
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[899@235 mouseUp 55305583 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts' 'TestPost>>#testPostVoteValue' 'TestPos...etc...
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	899@235 corner: 915@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	899@235 corner: 915@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(848822272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[899@235 mouseUp 55305583 nil]
		targetOffset: 	139@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55305583 899 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(856948736) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[899@235 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(856948736) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	899@235 corner: 915@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	899@235 corner: 915@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(848822272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[899@235 mouseUp 55305583 nil]
		targetOffset: 	139@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55305583 899 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	899@235 corner: 915@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	899@235 corner: 915@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(848822272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[899@235 mouseUp 55305583 nil]
		targetOffset: 	139@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55305583 899 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
	Receiver's instance variables: 
		bounds: 	899@235 corner: 915@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	899@235 corner: 915@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(848822272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[899@235 mouseUp 55305583 nil]
		targetOffset: 	139@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55305583 899 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[899@235 mouseUp 55305583 nil]
		evt: 	[899@235 mouseUp 55305583 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	899@235 corner: 915@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	899@235 corner: 915@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(848822272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[899@235 mouseUp 55305583 nil]
		targetOffset: 	139@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55305583 899 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[899@235 mouseUp 55305583 nil]
		evtBuf: 	#(1 55305583 899 235 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	899@235 corner: 915@251
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	899@235 corner: 915@251
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(848822272)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[899@235 mouseUp 55305583 nil]
		targetOffset: 	139@12
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55305583 899 235 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	10384726
		lastStepMessage: 	nil
		lastCycleTime: 	10384766
		alarms: 	a Heap()
		lastAlarmTime: 	10384726
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 0 but was -1.
4 July 2011 2:05:51 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 0 but was -1.'
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		expected: 	0
		actual: 	-1
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost>>testLastVoteCounts
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testLastVoteCounts
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testLastVoteCounts


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241150
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testLastVoteCounts)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testLastVoteCounts nil nil nil nil nil nil n...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241150
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241150
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241150
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testLastVoteCounts
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241150
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testLastVoteCounts)
		failedSelected: 	TestPost>>#testLastVoteCounts
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241150
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		event: 	[870@231 mouseUp 55450430 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [870@231 mouseUp 55450430 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		timeStamp: 	55450430
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	870@231
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		aMorph: 	a PluggableListMorph(883687424)
		localEvt: 	[870@231 mouseUp 55450430 nil]
		index: 	2
		child: 	a TransformMorph(472121344)
		morphs: 	an Array(a TransformMorph(472121344))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		aMorph: 	a PluggableListMorph(883687424)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(883687424)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
	Receiver's instance variables: 
		bounds: 	760@223 corner: 1071@416
		owner: 	a PluggableStandardWindow(900464640)
		submorphs: 	an Array(a TransformMorph(472121344))
		fullBounds: 	760@223 corner: 1071@416
		color: 	Color white
		extension: 	a MorphExtension (996409344) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(890503168)
		scroller: 	a TransformMorph(472121344)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(682885120)
		list: 	#('TestPost>>#testLastVoteCounts')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(701497344)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	870@231 corner: 886@247
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@231 corner: 886@247
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(310116352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@231 mouseUp 55450430 nil]
		targetOffset: 	110@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55450430 870 231 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(317980672) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[870@231 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@690
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(317980672) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	870@231 corner: 886@247
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@231 corner: 886@247
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(310116352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@231 mouseUp 55450430 nil]
		targetOffset: 	110@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55450430 870 231 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		focusHolder: 	a PluggableListMorph(883687424)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	870@231 corner: 886@247
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@231 corner: 886@247
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(310116352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@231 mouseUp 55450430 nil]
		targetOffset: 	110@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55450430 870 231 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
	Receiver's instance variables: 
		bounds: 	870@231 corner: 886@247
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@231 corner: 886@247
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(310116352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@231 mouseUp 55450430 nil]
		targetOffset: 	110@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55450430 870 231 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[870@231 mouseUp 55450430 nil]
		evt: 	[870@231 mouseUp 55450430 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	870@231 corner: 886@247
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@231 corner: 886@247
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(310116352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@231 mouseUp 55450430 nil]
		targetOffset: 	110@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55450430 870 231 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[870@231 mouseUp 55450430 nil]
		evtBuf: 	#(1 55450430 870 231 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	870@231 corner: 886@247
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	870@231 corner: 886@247
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(310116352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[870@231 mouseUp 55450430 nil]
		targetOffset: 	110@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 55450430 870 231 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@690
		canvas: 	a FormCanvas on: DisplayScreen(1224x690x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(479199232))(an Ove...etc...
		lastStepTime: 	10529585
		lastStepMessage: 	nil
		lastCycleTime: 	10529625
		alarms: 	a Heap()
		lastAlarmTime: 	10529585
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testLastVoteCounts
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
BreakPoint: 
4 July 2011 2:57:54 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

ByteString(Object)>>break
	Receiver: 'stephan'
	Arguments and temporary variables: 

	Receiver's instance variables: 
'stephan'

[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	88
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
ByteString(Object)>>break
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "answer" is nil
4 July 2011 2:58:02 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #answer
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	answer
		exception: 	MessageNotUnderstood: receiver of "answer" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	88
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #answer
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
BreakPoint: 
4 July 2011 2:58:13 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

ByteString(Object)>>break
	Receiver: 'stephan'
	Arguments and temporary variables: 

	Receiver's instance variables: 
'stephan'

[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	88
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
ByteString(Object)>>break
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAskQuestion>>answerToQuestion
4 July 2011 3:01:20 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAskQuestion(Object)>>doesNotUnderstand: #answerToQuestion
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		aMessage: 	answerToQuestion
		exception: 	MessageNotUnderstood: FOAskQuestion>>answerToQuestion
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


WATextAreaTag(WAFormInputTag)>>on:of:
	Receiver: a WATextAreaTag
	Arguments and temporary variables: 
		aSelector: 	#answerToQuestion
		anObject: 	a FOAskQuestion
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('rows'->'auto' 'cols'->'auto')
		value: 	nil


[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: self.
	canvas break.
	canvas submitButton on: #postYourAnswer of: self] in FOAskQuestion>>renderContentOn:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: self.
	canvas break.
	...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAskQuestion>>renderContentOn:
		startpc: 	132
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: s...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: s...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: s...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WAFormTag(WABrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: s...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


WARenderCanvas(WAHtmlCanvas)>>form:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: sel...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


FOAskQuestion>>renderContentOn:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOAskQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOAskQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOAskQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOAskQuestion(WAComponent)>>accept:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOAskQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOAskQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOAskQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOAskQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOAskQuestion(WAComponent)>>accept:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOAskQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOAskQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOAskQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOAskQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


FOAskQuestion(WAPainter)>>renderOn:
	Receiver: a FOAskQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOAskQuestion
		title: 	nil
		contents: 	nil
		tags: 	nil
		author: 	nil
		question: 	nil
		answer: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOAskQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOAskQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOAskQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
FOAskQuestion(Object)>>doesNotUnderstand: #answerToQuestion
WATextAreaTag(WAFormInputTag)>>on:of:
[canvas label: 'Answer'.
	canvas textArea on: #answerToQuestion of: self.
	canvas break.
	canvas submitButton on: #postYourAnswer of: self] in FOAskQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
WARenderCanvas(WAHtmlCanvas)>>form:
FOAskQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAskQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAskQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAskQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAskQuestion(WAPainter)>>renderWithContext:
FOAskQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
BreakPoint: 
4 July 2011 3:04:08 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

ByteString(Object)>>break
	Receiver: 'stephan'
	Arguments and temporary variables: 

	Receiver's instance variables: 
'stephan'

[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit;
		
		form: [canvas label: 'Answer']] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	100
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
ByteString(Object)>>break
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit;
		
		form: [canvas label: 'Answer']] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "answer" is nil
4 July 2011 3:04:12 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #answer
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	answer
		exception: 	MessageNotUnderstood: receiver of "answer" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit;
		
		form: [canvas label: 'Answer']] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	100
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #answer
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		 textArea: answerToQuestion answer;
		 break;
		 submitButton: answerToQuestion submit;
		
		form: [canvas label: 'Answer']] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
BreakPoint: 
4 July 2011 3:04:47 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

ByteString(Object)>>break
	Receiver: 'stephan'
	Arguments and temporary variables: 

	Receiver's instance variables: 
'stephan'

[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		
		form: [canvas label: 'Answer']] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	84
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
ByteString(Object)>>break
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName break;
		
		form: [canvas label: 'Answer']] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>canvas
4 July 2011 3:06:57 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

BlockClosure(Object)>>doesNotUnderstand: #canvas
	Receiver: [canvas label: 'Answer']
	Arguments and temporary variables: 
		aMessage: 	canvas
		exception: 	MessageNotUnderstood: BlockClosure>>canvas
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	ca...etc...
		startpc: 	139
		numArgs: 	0


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		 form: [canvas label: 'Answer'] canvas textArea on answerToQuestion] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	100
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #canvas
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		 form: [canvas label: 'Answer'] canvas textArea on answerToQuestion] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: BlockClosure>>canvas
4 July 2011 3:07:09 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

BlockClosure(Object)>>doesNotUnderstand: #canvas
	Receiver: [canvas label: 'Answer']
	Arguments and temporary variables: 
		aMessage: 	canvas
		exception: 	MessageNotUnderstood: BlockClosure>>canvas
		resumeValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	ca...etc...
		startpc: 	131
		numArgs: 	0


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		 form: [canvas label: 'Answer'] canvas textArea] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	92
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	nil


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')



--- The full stack ---
BlockClosure(Object)>>doesNotUnderstand: #canvas
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		 form: [canvas label: 'Answer'] canvas textArea] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>contents:
4 July 2011 3:22:56 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAnswer(Object)>>doesNotUnderstand: #contents:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	contents: 'blaa'
		exception: 	MessageNotUnderstood: FOAnswer>>contents:
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	nil
		votes: 	nil
		content: 	nil
		accepted: 	nil


FOQuestion>>newAnswer:contents:
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		anAuthor: 	nil
		aString: 	'blaa'
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection()
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	nil


FOViewQuestion>>postYourAnswer
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOViewQuestion selector: #postYourAnswer
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOViewQuestion
		selector: 	#postYourAnswer


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOViewQuestion selector: #postYourAnswer
	Arguments and temporary variables: 
		anArray: 	#('Post Your Answer')
	Receiver's instance variables: 
		receiver: 	a FOViewQuestion
		selector: 	#postYourAnswer


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
		key: 	'EOfaIi59101JlG_i'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	15154374
		previousTiming: 	30


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	15154374
		previousTiming: 	30


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	15154374
		previousTiming: 	30


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #contents:
FOQuestion>>newAnswer:contents:
FOViewQuestion>>postYourAnswer
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOQuestion>>hasAnswers
4 July 2011 3:27:26 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOQuestion(Object)>>doesNotUnderstand: #hasAnswers
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		aMessage: 	hasAnswers
		exception: 	MessageNotUnderstood: FOQuestion>>hasAnswers
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'How do I logout. I can''t seem to find a button for it.'
		answers: 	an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
		title: 	'Logout'
		tags: 	an OrderedCollection()
		comments: 	nil


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	108
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Marthyn'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
FOQuestion(Object)>>doesNotUnderstand: #hasAnswers
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOQuestion>>nrOfAnswersString
4 July 2011 3:28:58 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOQuestion(Object)>>doesNotUnderstand: #nrOfAnswersString
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		aMessage: 	nrOfAnswersString
		exception: 	MessageNotUnderstood: FOQuestion>>nrOfAnswersString
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'How do I logout. I can''t seem to find a button for it.'
		answers: 	an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
		title: 	'Logout'
		tags: 	an OrderedCollection()
		comments: 	nil


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	108
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'



--- The full stack ---
FOQuestion(Object)>>doesNotUnderstand: #nrOfAnswersString
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>title
4 July 2011 3:30:14 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAnswer(Object)>>doesNotUnderstand: #title
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	title
		exception: 	MessageNotUnderstood: FOAnswer>>title
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	nil
		content: 	'blaa'
		accepted: 	nil


[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn: canvas.
	canvas tex...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	5


[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:an...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	108
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #title
[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>votesTotal
4 July 2011 3:31:01 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAnswer(Object)>>doesNotUnderstand: #votesTotal
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	votesTotal
		exception: 	MessageNotUnderstood: FOAnswer>>votesTotal
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	nil
		content: 	'blaa'
		accepted: 	nil


[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer votesTotal;
		 break.
	canvas anchor
		callback: [anAnswer downvote];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canva...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:votesOn:
		startpc: 	81
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'votes')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'votes')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'votes')


FOViewQuestion>>renderAnswer:votesOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
	...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	61
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:an...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #votesTotal
[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer votesTotal;
		 break.
	canvas anchor
		callback: [anAnswer downvote];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:votesOn:
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>contents
4 July 2011 3:32:37 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAnswer(Object)>>doesNotUnderstand: #contents
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	contents
		exception: 	MessageNotUnderstood: FOAnswer>>contents
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'blaa'
		accepted: 	nil


[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
	...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	61
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:an...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	108
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'blaa'



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #contents
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAuthor>>author
4 July 2011 3:37:58 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAuthor(Object)>>doesNotUnderstand: #author
	Receiver: a FOAuthor
	Arguments and temporary variables: 
		aMessage: 	author
		exception: 	MessageNotUnderstood: FOAuthor>>author
		resumeValue: 	nil
	Receiver's instance variables: 
		model: 	a FOModel
		userName: 	'Marthyn'


FOQuestion>>newAnswer:content:
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
		aString: 	'hoi'
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection(a FOAnswer a FOAnswer)
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	nil


FOViewQuestion>>postYourAnswer
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOViewQuestion selector: #postYourAnswer
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOViewQuestion
		selector: 	#postYourAnswer


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOViewQuestion selector: #postYourAnswer
	Arguments and temporary variables: 
		anArray: 	#('Post Your Answer')
	Receiver's instance variables: 
		receiver: 	a FOViewQuestion
		selector: 	#postYourAnswer


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
		key: 	'EbEyNiOsJh_webhn'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	16056328
		previousTiming: 	25


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	16056328
		previousTiming: 	25


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	16056328
		previousTiming: 	25


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:



--- The full stack ---
FOAuthor(Object)>>doesNotUnderstand: #author
FOQuestion>>newAnswer:content:
FOViewQuestion>>postYourAnswer
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAuthor>>author
4 July 2011 3:38:30 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAuthor(Object)>>doesNotUnderstand: #author
	Receiver: a FOAuthor
	Arguments and temporary variables: 
		aMessage: 	author
		exception: 	MessageNotUnderstood: FOAuthor>>author
		resumeValue: 	nil
	Receiver's instance variables: 
		model: 	a FOModel
		userName: 	'Marthyn'


FOQuestion>>newAnswer:content:
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
		aString: 	'hoi'
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection(a FOAnswer a FOAnswer)
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	nil


FOViewQuestion>>postYourAnswer
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOViewQuestion selector: #postYourAnswer
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOViewQuestion
		selector: 	#postYourAnswer


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOViewQuestion selector: #postYourAnswer
	Arguments and temporary variables: 
		anArray: 	#('Post Your Answer')
	Receiver's instance variables: 
		receiver: 	a FOViewQuestion
		selector: 	#postYourAnswer


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
		key: 	'EbEyNiOsJh_webhn'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	16089006
		previousTiming: 	5610


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	16089006
		previousTiming: 	5610


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	16089006
		previousTiming: 	5610


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=8aBkzbn5ZpGgxrYZ&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:



--- The full stack ---
FOAuthor(Object)>>doesNotUnderstand: #author
FOQuestion>>newAnswer:content:
FOViewQuestion>>postYourAnswer
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAuthor>>username
4 July 2011 3:38:42 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAuthor(Object)>>doesNotUnderstand: #username
	Receiver: a FOAuthor
	Arguments and temporary variables: 
		aMessage: 	username
		exception: 	MessageNotUnderstood: FOAuthor>>username
		resumeValue: 	nil
	Receiver's instance variables: 
		model: 	a FOModel
		userName: 	'Marthyn'


[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author username] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer ...etc...
		firstIndex: 	3
		lastIndex: 	7


[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:an...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question answerSizeString.
	questi...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	108
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	'hoi'



--- The full stack ---
FOAuthor(Object)>>doesNotUnderstand: #username
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author username] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question answerSizeString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break;
		
		form: [canvas label: 'Answer'.
			canvas textArea on: #answerToQuestion of: self.
			canvas submitButton on: #postYourAnswer of: self].
	self renderAnswersOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>upvote
4 July 2011 4:02:14 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOAnswer(Object)>>doesNotUnderstand: #upvote
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	upvote
		exception: 	MessageNotUnderstood: FOAnswer>>upvote
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'blaa'
		accepted: 	nil


[anAnswer upvote] in [canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer voteSize;
		 break.
	canvas anchor
		callback: [anAnswer downvote];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''


BlockClosure>>valueWithPossibleArguments:
	Receiver: [anAnswer upvote]
	Arguments and temporary variables: 
		anArray: 	#(nil)
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas ...etc...
		startpc: 	89
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	27


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	27


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
		key: 	'yRaZVVmVLk0rCbVH'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	17511946
		previousTiming: 	265


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	17511946
		previousTiming: 	265


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	17511946
		previousTiming: 	265


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #upvote
[anAnswer upvote] in [canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer voteSize;
		 break.
	canvas anchor
		callback: [anAnswer downvote];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>voteUp:
4 July 2011 4:05:33 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

ByteString(Object)>>doesNotUnderstand: #voteUp:
	Receiver: ''
	Arguments and temporary variables: 
		aMessage: 	voteUp: a FOAuthor
		exception: 	MessageNotUnderstood: ByteString>>voteUp:
		resumeValue: 	nil
	Receiver's instance variables: 
''

[answerToQuestion voteUp: self user] in [canvas anchor
		callback: [answerToQuestion voteUp: self user];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer voteSize;
		 break.
	canvas anchor
		callback: [answerToQuestion voteDown: self user];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''


BlockClosure>>valueWithPossibleArguments:
	Receiver: [answerToQuestion voteUp: self user]
	Arguments and temporary variables: 
		anArray: 	#(nil)
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	[canvas anchor
		callback: [answerToQuestion voteUp: self user];
...etc...
		startpc: 	92
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
		key: 	'gBq4hAD3MyDW1um0'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	17711885
		previousTiming: 	63


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	17711885
		previousTiming: 	63


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	17711885
		previousTiming: 	63


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=A6I3homTlSLsEzCW&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #voteUp:
[answerToQuestion voteUp: self user] in [canvas anchor
		callback: [answerToQuestion voteUp: self user];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer voteSize;
		 break.
	canvas anchor
		callback: [answerToQuestion voteDown: self user];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOQuestion>>hasComment
4 July 2011 4:23:17 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOQuestion(Object)>>doesNotUnderstand: #hasComment
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		aMessage: 	hasComment
		exception: 	MessageNotUnderstood: FOQuestion>>hasComment
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection(a FOAnswer a FOAnswer)
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	an OrderedCollection(a FOComment)


FOViewQuestion>>renderCommentsOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Erik'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Erik'


[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Erik'


BlockClosure>>renderOn:
	Receiver: [self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBo...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderContentOn:
		startpc: 	44
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
FOQuestion(Object)>>doesNotUnderstand: #hasComment
FOViewQuestion>>renderCommentsOn:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOQuestion>>hasComment
4 July 2011 4:23:49 pm

VM: Win32 - IX86 - 6.1 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources
Trusted Dir C:\Users\Marthyn\Smalltalk\Seaside.app\Contents\Resources\Marthyn
Untrusted Dir C:\Users\Marthyn\Documents\My Squeak

FOQuestion(Object)>>doesNotUnderstand: #hasComment
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		aMessage: 	hasComment
		exception: 	MessageNotUnderstood: FOQuestion>>hasComment
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection(a FOAnswer a FOAnswer)
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	an OrderedCollection(a FOComment)


FOViewQuestion>>renderCommentsOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answerToQuestion: 	''
		commentToQuestion: 	'Blaa'


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Erik'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Erik'


[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Erik'


BlockClosure>>renderOn:
	Receiver: [self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBo...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderContentOn:
		startpc: 	44
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
FOQuestion(Object)>>doesNotUnderstand: #hasComment
FOViewQuestion>>renderCommentsOn:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

